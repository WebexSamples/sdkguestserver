<!DOCTYPE html>
<html>

<head>
  <title>Webex Guest Issuer (sample app)</title>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="styles.css">

</head>

<body>
  <div id="content">
    <h1>Webex Guest Issuer App example: Stage 5</h1>
    <div id="status"></div>
    
    
    <!-- Single Party Call HTML -->
    <form id="call-controls">
      <fieldset>
        <legend>Call Controls</legend>
        <button id="call" title="call" type="button" disabled >call</button>
        <button id="hangup" title="hangup" type="button" disabled>cancel/hangup</button>
      </fieldset>
    </form>

    <div style="display: flex">
      <div id="self-video" style="width: 400px;">
        <video style="width:100%; height: auto;" id="self-view" muted autoplay></video>
      </div>
      <div id="remote-video" style="width: 400px;">
        <audio id="remote-view-audio" autoplay></audio>
        <video id="remote-view-video" autoplay style="width:100%; height: auto;"></video>
      </div>
    </div>
    <!-- Single Party Call HTML END -->

  <!-- we are limited to repl.it resources, so load bundle externally -->
  <script src="https://js.samples.s4d.io/bundle.js"></script>

<script>
  <!-- Single Party Call JS -->
  // Inititate the SDK
  const spark = ciscospark.init();

  const jwt = '<%=locals.token%>';
  const statusDiv = document.getElementById('status');
  const callButton = document.getElementById('call');
  const hangupButton = document.getElementById('hangup');
  statusDiv.innerHTML = 'Loading';
  
  spark.once('ready', () => {
    statusDiv.innerHTML = 'Authorizing';
    spark.authorization.requestAccessTokenFromJwt({jwt}).then(() => {
        if (spark.canAuthorize) {
          // Authorization is successful
          // Change Authentication status to `Authorized`
          statusDiv.innerHTML = 'Authorized!';
          
          spark.phone.register()
            .then(() => {
              // Enable our call button
              callButton.disabled = false;
              statusDiv.innerHTML = 'Connected: Ready to call';
            })
            .catch((err) => {
              console.error(err);
              statusDiv.innerHTML('Unable to connect');
            });
        }
      })
        .catch((e) => {
          // Do something with the auth error here
          console.error(e);
          statusDiv.innerHTML = 'Unable to Login.';
        });
    });

  // Call Button Click
  callButton.addEventListener('click', (event) => {
    // we don't want to reload when we try to dial
    event.preventDefault();
    callButton.disabled = true;
    const call = spark.phone.dial('roomkit@sparkdemos.com');
    statusDiv.innerHTML = 'Calling!';
    
    call.on('error', (err) => {
      console.error(err);
      alert(err.stack);
    });
  
    // Add the self view
    call.once('localMediaStream:change', () => {
      document.getElementById('self-view').srcObject = call.localMediaStream;
    });

    call.on('remoteMediaStream:change', () => {
      // Ok, yea, this is a little weird. There's a Chrome behavior that prevents
      // audio from playing from a video tag if there is no corresponding video
      // track.
      [
        'audio',
        'video'
      ].forEach((kind) => {
        if (call.remoteMediaStream) {
          const track = call.remoteMediaStream.getTracks().find((t) => t.kind === kind);
          if (track) {
            document.getElementById(`remote-view-${kind}`).srcObject = new MediaStream([track]);
          }
          statusDiv.innerHTML = 'Connected!';
        }
      });
    });

    // Once the call ends, we'll want to clean up our UI a bit
    call.on('inactive', () => {
      // Remove the streams from the UI elements
      document.getElementById('self-view').srcObject = undefined;
      document.getElementById('remote-view-audio').srcObject = undefined;
      document.getElementById('remote-view-video').srcObject = undefined;
      statusDiv.innerHTML = 'Connected: Ready to call';
      callButton.disabled = false;
      hangupButton.disabled = true;
    });

    // Of course, we'd also like to be able to end the call:
    hangupButton.disabled = false;
    hangupButton.addEventListener('click', () => {
      call.hangup();
    });
  });

  <!-- Single Party Call JS END -->
</script>
  </div>
</body>

</html>